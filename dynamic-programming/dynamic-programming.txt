DP = Recursion + Memoization

"DP is an approach to solving complex problems which involves breaking the problem down into simpler problems 
    and solving those problems first"
    - This approach can be particularly effective when solving problems that have overlapping sub-problems.

typically in a dynamic programming problem, we store the computed subproblem results in an array as we build up to
    solve the full solution. And depending on the variables involved, this array could have various dimensions causing us to need
    to store various computations for each subproblem as the variables change. This is the multi-dimension aspect of DP.

    "what is the 1D DP??" -> "it means that you just use a 1 Dimensional that is a simple array to store the computed results. 2D would use values from two or possibly more elements from the matrix (2d array)"
    "if you know dynamic programming then you must know what a state is. When your state can be represented by just one identifier (one - Dimension) you use a linear data structure to hold it.If your state is uniquely represented using two variables (two dimensions) then you need a 2D array or matrix to store the computed result. Similarly for 3d dp."
    "the number of dimensions encoding the subproblems"

_______________
Dynamic programming has 3 steps:
———————————––––
1. Break the problem into easier/recursive subproblems.
2. As you solve the subproblems, remember each one’s solution.
3. If you encounter a subproblem that’s identical to one you’ve already solved, use the previous solution instead of recalculating it.
———————————––––––

this one makes less sense to me but:
"Dynamic programming is designed such that “the optimal solution to the overall problem depends upon the optimal 
    solution to its subproblems.”

"The key to dynamic programming is to identify the subproblem that gives the main problem
    “optimal substructure property.”

"Optimal Substructure" Property:
"Optimal Substructure: If a problem can be solved by using the solutions of the sub problems then we say that problem has a Optimal Substructure Property."
"A formal way of saying that the key is to identify the subproblem that will allow us us to solve the main problem by just solving the subproblem repeatedly"

Recusively solving and memoizing sub problems as a means of solving the overall solution.
A big part of it is finding the correct sub problems to solve.

Bottom-Up Approach: Compute Subproblems First and 
- Suppose we need to solve the problem for N, We start solving the problem with the smallest possible inputs and store it for future. Now as you calculate for the bigger values use the stored solutions (solution for smaller problems).  
- some people prefer this approach because it (can often?) be done without function calls

Top-Down Approach: Break the problem into sub-problems and solve them as needed and store the solution for future

various DP problem patterns:
Minimum (Maximum) Path to Reach a Target
    https://leetcode.com/list/55ac4kuc/
Distinct Ways
Merging Intervals
DP on Strings
Decision Making

on the *dimensions* of a dynamic programming problem
"a variety of dynamic programming that is well-suited to problems that have multiple dimensions or variables"


resources:
https://youtu.be/vYquumk4nWw?si=117daxY32dyRuFwZ
https://www.youtube.com/watch?v=aPQY__2H3tE
coin change / dp guide: https://betterprogramming.pub/learn-dynamic-programming-the-coin-change-problem-22a104478f50
dp guide on LC: https://leetcode.com/discuss/study-guide/458695/Dynamic-Programming-Patterns
on dimensions: https://iamsuman.com/multi-dimensional-dynamic-programming-an-introduction#